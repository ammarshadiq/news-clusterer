/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * EvaluationViewDialog.java
 *
 * Created on May 13, 2011, 9:12:42 PM
 */
package newsclusteringlucene.evaluation;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import javax.swing.JFileChooser;
import newsclusteringlucene.Configuration;
import newsclusteringlucene.graph.Vertex;
import newsclusteringlucene.population.LuceneIndexDocument;
import newsclusteringlucene.utils.Cluster;

/**
 *
 * @author shadiq
 */
public class EvaluationViewDialog extends javax.swing.JDialog {
  
  private ArrayList<Vertex> vertices;
  private ArrayList<Cluster> mergedClusters;
  
  private Configuration appConf;
  
  private HashSet<String> includedURLList; // would be often searched, so its hashed.
  
  // <URL, TopicID>
  private HashMap<String, Integer> URLTopicClusterList; // would be often searched, so its hashed.
  
  /** Contains:
    * Contains :
    * Integer : TopicID 1
    *      String : URL 1
    *      String : URL 2
    *      String : URL 3
    * Integer : TopicID 2
    *      String : URL 4
    *      ...
    * ...
    */
  // <TopicID, <URL>>
  private HashMap<Integer, ArrayList<String>> topicURLClusterList; // would be often searched, so its hashed.
  
  // <TopicID, Topic>
  private HashMap<Integer, Topic> topicList; // would be often searched, so its hashed.

  // <ClusterIndex <TopicID, NumOfDoc>>
  //private HashMap<Integer, HashMap<Integer, Integer>> clusterTopicMap; 
          //= new HashMap<Integer, HashMap<Integer, Integer>>();
  
  public EvaluationViewDialog(java.awt.Frame parent, boolean modal, 
          Configuration appConf, ArrayList<Vertex> vertices, ArrayList<Cluster> mergedClusters) {
    super(parent, modal);
    this.vertices = vertices;
    this.mergedClusters = mergedClusters;
    this.appConf = appConf;
    
    initComponents();
    chooser.setCurrentDirectory(new File("."));
  }
  
  public static void showDialog(java.awt.Frame parent, boolean modal,
          Configuration appConf, ArrayList<Vertex> vertices, ArrayList<Cluster> mergedClusters) {
    evaluationViewDialog = new EvaluationViewDialog(parent, modal, appConf, vertices, mergedClusters);
    evaluationViewDialog.setLocationRelativeTo(parent);
    evaluationViewDialog.setVisible(true);
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    clusteringEvaluationLabel = new javax.swing.JLabel();
    manualClusterFileLabel = new javax.swing.JLabel();
    manualClusterFileTextField = new javax.swing.JTextField();
    manualClusterFileBrowseButton = new javax.swing.JButton();
    manualClusterLabelingFileTextField = new javax.swing.JTextField();
    manualClusterLabelingFileBrowseButton = new javax.swing.JButton();
    manualClusterLabelingFileLabel = new javax.swing.JLabel();
    closeButton = new javax.swing.JButton();
    jCheckBox1 = new javax.swing.JCheckBox();
    jCheckBox2 = new javax.swing.JCheckBox();
    jCheckBox3 = new javax.swing.JCheckBox();
    jCheckBox4 = new javax.swing.JCheckBox();
    clusteringEvaluationPrecisionRecallCheckBox = new javax.swing.JCheckBox();
    clusteringEvaluationFMeasureCheckBox = new javax.swing.JCheckBox();
    jScrollPane1 = new javax.swing.JScrollPane();
    evaluationResultTextArea = new javax.swing.JTextArea();
    evaluateButton = new javax.swing.JButton();
    clusterEvaluationCalculateLabel = new javax.swing.JLabel();
    jLabel8 = new javax.swing.JLabel();
    jLabel6 = new javax.swing.JLabel();
    jSpinner1 = new javax.swing.JSpinner();
    clusteringEvaluationRefLabel = new javax.swing.JLabel();
    clusterLabelingEvaluationRefLabel = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    jCheckBox8 = new javax.swing.JCheckBox();
    jCheckBox9 = new javax.swing.JCheckBox();
    jCheckBox10 = new javax.swing.JCheckBox();
    clusteringEvaluationPurityCheckBox = new javax.swing.JCheckBox();
    clusteringEvaluationFMeasureBetaSpinner = new javax.swing.JSpinner();
    clusteringEvaluationFMeasureBetaLabel = new javax.swing.JLabel();
    jCheckBox5 = new javax.swing.JCheckBox();
    jLabel1 = new javax.swing.JLabel();
    clusteringEvaluationFMeasureBetaLabel1 = new javax.swing.JLabel();
    clusteringEvaluationFMeasureBetaSpinner1 = new javax.swing.JSpinner();
    jLabel4 = new javax.swing.JLabel();
    jLabel5 = new javax.swing.JLabel();
    jSpinner2 = new javax.swing.JSpinner();
    jComboBox1 = new javax.swing.JComboBox();
    jCheckBox6 = new javax.swing.JCheckBox();
    jCheckBox7 = new javax.swing.JCheckBox();

    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    setName("Form"); // NOI18N

    org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(newsclusteringlucene.NewsClusteringLuceneApp.class).getContext().getResourceMap(EvaluationViewDialog.class);
    clusteringEvaluationLabel.setFont(resourceMap.getFont("clusteringEvaluationLabel.font")); // NOI18N
    clusteringEvaluationLabel.setText(resourceMap.getString("clusteringEvaluationLabel.text")); // NOI18N
    clusteringEvaluationLabel.setName("clusteringEvaluationLabel"); // NOI18N

    manualClusterFileLabel.setFont(resourceMap.getFont("jCheckBox5.font")); // NOI18N
    manualClusterFileLabel.setText(resourceMap.getString("manualClusterFileLabel.text")); // NOI18N
    manualClusterFileLabel.setName("manualClusterFileLabel"); // NOI18N

    manualClusterFileTextField.setFont(resourceMap.getFont("jCheckBox5.font")); // NOI18N
    manualClusterFileTextField.setText(resourceMap.getString("manualClusterFileTextField.text")); // NOI18N
    manualClusterFileTextField.setName("manualClusterFileTextField"); // NOI18N

    manualClusterFileBrowseButton.setFont(resourceMap.getFont("jCheckBox5.font")); // NOI18N
    manualClusterFileBrowseButton.setText(resourceMap.getString("manualClusterFileBrowseButton.text")); // NOI18N
    manualClusterFileBrowseButton.setName("manualClusterFileBrowseButton"); // NOI18N
    manualClusterFileBrowseButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        manualClusterFileBrowseButtonActionPerformed(evt);
      }
    });

    manualClusterLabelingFileTextField.setFont(resourceMap.getFont("jCheckBox4.font")); // NOI18N
    manualClusterLabelingFileTextField.setText(resourceMap.getString("manualClusterLabelingFileTextField.text")); // NOI18N
    manualClusterLabelingFileTextField.setName("manualClusterLabelingFileTextField"); // NOI18N

    manualClusterLabelingFileBrowseButton.setFont(resourceMap.getFont("jCheckBox4.font")); // NOI18N
    manualClusterLabelingFileBrowseButton.setText(resourceMap.getString("manualClusterLabelingFileBrowseButton.text")); // NOI18N
    manualClusterLabelingFileBrowseButton.setName("manualClusterLabelingFileBrowseButton"); // NOI18N
    manualClusterLabelingFileBrowseButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        manualClusterLabelingFileBrowseButtonActionPerformed(evt);
      }
    });

    manualClusterLabelingFileLabel.setFont(resourceMap.getFont("jCheckBox4.font")); // NOI18N
    manualClusterLabelingFileLabel.setText(resourceMap.getString("manualClusterLabelingFileLabel.text")); // NOI18N
    manualClusterLabelingFileLabel.setName("manualClusterLabelingFileLabel"); // NOI18N

    closeButton.setText(resourceMap.getString("closeButton.text")); // NOI18N
    closeButton.setName("closeButton"); // NOI18N
    closeButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        closeButtonActionPerformed(evt);
      }
    });

    jCheckBox1.setFont(resourceMap.getFont("jCheckBox4.font")); // NOI18N
    jCheckBox1.setSelected(true);
    jCheckBox1.setText(resourceMap.getString("jCheckBox1.text")); // NOI18N
    jCheckBox1.setName("jCheckBox1"); // NOI18N

    jCheckBox2.setFont(resourceMap.getFont("jCheckBox4.font")); // NOI18N
    jCheckBox2.setSelected(true);
    jCheckBox2.setText(resourceMap.getString("jCheckBox2.text")); // NOI18N
    jCheckBox2.setName("jCheckBox2"); // NOI18N

    jCheckBox3.setFont(resourceMap.getFont("jCheckBox4.font")); // NOI18N
    jCheckBox3.setSelected(true);
    jCheckBox3.setText(resourceMap.getString("jCheckBox3.text")); // NOI18N
    jCheckBox3.setName("jCheckBox3"); // NOI18N

    jCheckBox4.setFont(resourceMap.getFont("jCheckBox4.font")); // NOI18N
    jCheckBox4.setSelected(true);
    jCheckBox4.setText(resourceMap.getString("jCheckBox4.text")); // NOI18N
    jCheckBox4.setName("jCheckBox4"); // NOI18N

    clusteringEvaluationPrecisionRecallCheckBox.setFont(resourceMap.getFont("jCheckBox5.font")); // NOI18N
    clusteringEvaluationPrecisionRecallCheckBox.setSelected(true);
    clusteringEvaluationPrecisionRecallCheckBox.setText(resourceMap.getString("clusteringEvaluationPrecisionRecallCheckBox.text")); // NOI18N
    clusteringEvaluationPrecisionRecallCheckBox.setName("clusteringEvaluationPrecisionRecallCheckBox"); // NOI18N

    clusteringEvaluationFMeasureCheckBox.setFont(resourceMap.getFont("jCheckBox5.font")); // NOI18N
    clusteringEvaluationFMeasureCheckBox.setSelected(true);
    clusteringEvaluationFMeasureCheckBox.setText(resourceMap.getString("clusteringEvaluationFMeasureCheckBox.text")); // NOI18N
    clusteringEvaluationFMeasureCheckBox.setName("clusteringEvaluationFMeasureCheckBox"); // NOI18N

    jScrollPane1.setName("jScrollPane1"); // NOI18N

    evaluationResultTextArea.setColumns(20);
    evaluationResultTextArea.setEditable(false);
    evaluationResultTextArea.setFont(resourceMap.getFont("evaluationResultTextArea.font")); // NOI18N
    evaluationResultTextArea.setRows(5);
    evaluationResultTextArea.setText(resourceMap.getString("evaluationResultTextArea.text")); // NOI18N
    evaluationResultTextArea.setBorder(javax.swing.BorderFactory.createTitledBorder(resourceMap.getString("evaluationResultTextArea.border.title"))); // NOI18N
    evaluationResultTextArea.setName("evaluationResultTextArea"); // NOI18N
    jScrollPane1.setViewportView(evaluationResultTextArea);

    evaluateButton.setFont(resourceMap.getFont("evaluateButton.font")); // NOI18N
    evaluateButton.setText(resourceMap.getString("evaluateButton.text")); // NOI18N
    evaluateButton.setName("evaluateButton"); // NOI18N
    evaluateButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        evaluateButtonActionPerformed(evt);
      }
    });

    clusterEvaluationCalculateLabel.setFont(resourceMap.getFont("jCheckBox5.font")); // NOI18N
    clusterEvaluationCalculateLabel.setText(resourceMap.getString("clusterEvaluationCalculateLabel.text")); // NOI18N
    clusterEvaluationCalculateLabel.setName("clusterEvaluationCalculateLabel"); // NOI18N

    jLabel8.setFont(resourceMap.getFont("jCheckBox4.font")); // NOI18N
    jLabel8.setText(resourceMap.getString("jLabel8.text")); // NOI18N
    jLabel8.setName("jLabel8"); // NOI18N

    jLabel6.setFont(resourceMap.getFont("jCheckBox4.font")); // NOI18N
    jLabel6.setText(resourceMap.getString("jLabel6.text")); // NOI18N
    jLabel6.setName("jLabel6"); // NOI18N

    jSpinner1.setFont(resourceMap.getFont("jCheckBox4.font")); // NOI18N
    jSpinner1.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(5), Integer.valueOf(1), null, Integer.valueOf(1)));
    jSpinner1.setName("jSpinner1"); // NOI18N

    clusteringEvaluationRefLabel.setFont(resourceMap.getFont("clusteringEvaluationRefLabel.font")); // NOI18N
    clusteringEvaluationRefLabel.setText(resourceMap.getString("clusteringEvaluationRefLabel.text")); // NOI18N
    clusteringEvaluationRefLabel.setName("clusteringEvaluationRefLabel"); // NOI18N

    clusterLabelingEvaluationRefLabel.setFont(resourceMap.getFont("clusterLabelingEvaluationRefLabel.font")); // NOI18N
    clusterLabelingEvaluationRefLabel.setText(resourceMap.getString("clusterLabelingEvaluationRefLabel.text")); // NOI18N
    clusterLabelingEvaluationRefLabel.setName("clusterLabelingEvaluationRefLabel"); // NOI18N

    jLabel2.setFont(resourceMap.getFont("jCheckBox4.font")); // NOI18N
    jLabel2.setText(resourceMap.getString("jLabel2.text")); // NOI18N
    jLabel2.setName("jLabel2"); // NOI18N

    jCheckBox8.setFont(resourceMap.getFont("jCheckBox4.font")); // NOI18N
    jCheckBox8.setSelected(true);
    jCheckBox8.setText(resourceMap.getString("jCheckBox8.text")); // NOI18N
    jCheckBox8.setName("jCheckBox8"); // NOI18N

    jCheckBox9.setFont(resourceMap.getFont("jCheckBox4.font")); // NOI18N
    jCheckBox9.setSelected(true);
    jCheckBox9.setText(resourceMap.getString("jCheckBox9.text")); // NOI18N
    jCheckBox9.setName("jCheckBox9"); // NOI18N

    jCheckBox10.setFont(resourceMap.getFont("jCheckBox4.font")); // NOI18N
    jCheckBox10.setSelected(true);
    jCheckBox10.setText(resourceMap.getString("jCheckBox10.text")); // NOI18N
    jCheckBox10.setName("jCheckBox10"); // NOI18N

    clusteringEvaluationPurityCheckBox.setFont(resourceMap.getFont("jCheckBox5.font")); // NOI18N
    clusteringEvaluationPurityCheckBox.setSelected(true);
    clusteringEvaluationPurityCheckBox.setText(resourceMap.getString("clusteringEvaluationPurityCheckBox.text")); // NOI18N
    clusteringEvaluationPurityCheckBox.setName("clusteringEvaluationPurityCheckBox"); // NOI18N

    clusteringEvaluationFMeasureBetaSpinner.setFont(resourceMap.getFont("jCheckBox5.font")); // NOI18N
    clusteringEvaluationFMeasureBetaSpinner.setModel(new javax.swing.SpinnerNumberModel(Double.valueOf(1.0d), Double.valueOf(0.0d), null, Double.valueOf(0.01d)));
    clusteringEvaluationFMeasureBetaSpinner.setName("clusteringEvaluationFMeasureBetaSpinner"); // NOI18N

    clusteringEvaluationFMeasureBetaLabel.setFont(resourceMap.getFont("jCheckBox5.font")); // NOI18N
    clusteringEvaluationFMeasureBetaLabel.setText(resourceMap.getString("clusteringEvaluationFMeasureBetaLabel.text")); // NOI18N
    clusteringEvaluationFMeasureBetaLabel.setName("clusteringEvaluationFMeasureBetaLabel"); // NOI18N

    jCheckBox5.setFont(resourceMap.getFont("jCheckBox5.font")); // NOI18N
    jCheckBox5.setText(resourceMap.getString("jCheckBox5.text")); // NOI18N
    jCheckBox5.setName("jCheckBox5"); // NOI18N

    jLabel1.setFont(resourceMap.getFont("jRadioButton1.font")); // NOI18N
    jLabel1.setText(resourceMap.getString("jLabel1.text")); // NOI18N
    jLabel1.setName("jLabel1"); // NOI18N

    clusteringEvaluationFMeasureBetaLabel1.setFont(resourceMap.getFont("jRadioButton1.font")); // NOI18N
    clusteringEvaluationFMeasureBetaLabel1.setText(resourceMap.getString("clusteringEvaluationFMeasureBetaLabel1.text")); // NOI18N
    clusteringEvaluationFMeasureBetaLabel1.setEnabled(false);
    clusteringEvaluationFMeasureBetaLabel1.setName("clusteringEvaluationFMeasureBetaLabel1"); // NOI18N

    clusteringEvaluationFMeasureBetaSpinner1.setFont(resourceMap.getFont("jRadioButton1.font")); // NOI18N
    clusteringEvaluationFMeasureBetaSpinner1.setModel(new javax.swing.SpinnerNumberModel(Double.valueOf(1.0d), Double.valueOf(0.0d), null, Double.valueOf(0.01d)));
    clusteringEvaluationFMeasureBetaSpinner1.setEnabled(false);
    clusteringEvaluationFMeasureBetaSpinner1.setName("clusteringEvaluationFMeasureBetaSpinner1"); // NOI18N

    jLabel4.setFont(resourceMap.getFont("jLabel4.font")); // NOI18N
    jLabel4.setText(resourceMap.getString("jLabel4.text")); // NOI18N
    jLabel4.setName("jLabel4"); // NOI18N

    jLabel5.setFont(resourceMap.getFont("jRadioButton1.font")); // NOI18N
    jLabel5.setText(resourceMap.getString("jLabel5.text")); // NOI18N
    jLabel5.setName("jLabel5"); // NOI18N

    jSpinner2.setFont(resourceMap.getFont("jRadioButton1.font")); // NOI18N
    jSpinner2.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(10), Integer.valueOf(1), null, Integer.valueOf(1)));
    jSpinner2.setName("jSpinner2"); // NOI18N

    jComboBox1.setFont(resourceMap.getFont("jRadioButton1.font")); // NOI18N
    jComboBox1.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "By Cluster Max Precision", "By Cluster Max F-Measure" }));
    jComboBox1.setName("jComboBox1"); // NOI18N

    jCheckBox6.setFont(resourceMap.getFont("jCheckBox6.font")); // NOI18N
    jCheckBox6.setText(resourceMap.getString("jCheckBox6.text")); // NOI18N
    jCheckBox6.setName("jCheckBox6"); // NOI18N

    jCheckBox7.setFont(resourceMap.getFont("jCheckBox7.font")); // NOI18N
    jCheckBox7.setText(resourceMap.getString("jCheckBox7.text")); // NOI18N
    jCheckBox7.setName("jCheckBox7"); // NOI18N

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(layout.createSequentialGroup()
            .addGap(12, 12, 12)
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addGroup(layout.createSequentialGroup()
                .addComponent(manualClusterLabelingFileLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(manualClusterLabelingFileTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 207, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(manualClusterLabelingFileBrowseButton))
              .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                  .addComponent(jLabel8)
                  .addComponent(jLabel6))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addGroup(layout.createSequentialGroup()
                    .addComponent(jSpinner1, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(jCheckBox10))
                  .addGroup(layout.createSequentialGroup()
                    .addComponent(jCheckBox1)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(jCheckBox2)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(jCheckBox3)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(jCheckBox4))
                  .addGroup(layout.createSequentialGroup()
                    .addComponent(jLabel2)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(jCheckBox8)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(jCheckBox9)))))
            .addContainerGap())
          .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
              .addGap(12, 12, 12)
              .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                .addComponent(jLabel5)
                .addComponent(jLabel1))
              .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
              .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(jSpinner2, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createSequentialGroup()
                  .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 182, javax.swing.GroupLayout.PREFERRED_SIZE)
                  .addGap(12, 12, 12)
                  .addComponent(clusteringEvaluationFMeasureBetaLabel1)
                  .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                  .addComponent(clusteringEvaluationFMeasureBetaSpinner1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
              .addContainerGap())
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                  .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 464, Short.MAX_VALUE)
                  .addGroup(layout.createSequentialGroup()
                    .addComponent(clusteringEvaluationLabel)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(clusteringEvaluationRefLabel))
                  .addGroup(layout.createSequentialGroup()
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                      .addComponent(clusterEvaluationCalculateLabel)
                      .addComponent(manualClusterFileLabel))
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                      .addGroup(layout.createSequentialGroup()
                        .addComponent(manualClusterFileTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 270, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(manualClusterFileBrowseButton))
                      .addGroup(layout.createSequentialGroup()
                        .addComponent(clusteringEvaluationPrecisionRecallCheckBox)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(clusteringEvaluationFMeasureCheckBox)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(clusteringEvaluationFMeasureBetaLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(clusteringEvaluationFMeasureBetaSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE))
                      .addGroup(layout.createSequentialGroup()
                        .addComponent(clusteringEvaluationPurityCheckBox)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBox5)))
                    .addGap(2, 2, 2))
                  .addGroup(layout.createSequentialGroup()
                    .addComponent(jCheckBox6)
                    .addGap(2, 2, 2)
                    .addComponent(jLabel4))
                  .addGroup(layout.createSequentialGroup()
                    .addComponent(jCheckBox7)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(clusterLabelingEvaluationRefLabel))
                  .addComponent(evaluateButton, javax.swing.GroupLayout.DEFAULT_SIZE, 464, Short.MAX_VALUE))
                .addContainerGap())
              .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(closeButton)
                .addContainerGap())))))
    );

    layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {clusteringEvaluationFMeasureBetaSpinner, clusteringEvaluationFMeasureBetaSpinner1});

    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(clusteringEvaluationLabel)
          .addComponent(clusteringEvaluationRefLabel))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(manualClusterFileLabel)
          .addComponent(manualClusterFileTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(manualClusterFileBrowseButton))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(clusterEvaluationCalculateLabel)
          .addComponent(clusteringEvaluationPurityCheckBox)
          .addComponent(jCheckBox5))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(clusteringEvaluationPrecisionRecallCheckBox)
          .addComponent(clusteringEvaluationFMeasureCheckBox)
          .addComponent(clusteringEvaluationFMeasureBetaSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(clusteringEvaluationFMeasureBetaLabel))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(jCheckBox6)
          .addComponent(jLabel4))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(jLabel1)
          .addComponent(clusteringEvaluationFMeasureBetaLabel1)
          .addComponent(clusteringEvaluationFMeasureBetaSpinner1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(jSpinner2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(jLabel5))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(jCheckBox7)
          .addComponent(clusterLabelingEvaluationRefLabel))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(manualClusterLabelingFileLabel)
          .addComponent(manualClusterLabelingFileTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(manualClusterLabelingFileBrowseButton))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(jLabel6)
          .addComponent(jSpinner1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(jCheckBox10))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(jLabel8)
          .addComponent(jCheckBox1)
          .addComponent(jCheckBox2)
          .addComponent(jCheckBox3)
          .addComponent(jCheckBox4))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(jCheckBox8)
          .addComponent(jCheckBox9)
          .addComponent(jLabel2))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(evaluateButton)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 190, Short.MAX_VALUE)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(closeButton)
        .addContainerGap())
    );

    pack();
  }// </editor-fold>//GEN-END:initComponents

  private void evaluateButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_evaluateButtonActionPerformed
    // ONLY select the filtered url
    // for each vertex that are not filtered.
    StringBuilder sb = new StringBuilder(); 
    
    // create non filtered collection statistics
    Coll c = new Coll();
    c.generateClusterTopicMap(vertices, false);
    System.out.println("\nNum Of Doc");
    c.showNumOfNonFilteredDoc();
    System.out.println("\nCluster Topic Map");
    c.showClusterTopicMap();
    System.out.println("\nCollection Topic Map Sorted");
    c.showCollectionTopicMap();
    
    System.out.println("\nCluster Topic By Max Precision");
    c.generateClusterTopicByMaxPrecision();
    //System.out.println("\nCluster Topic By Max FMeasure");
    //c.generateClusterTopicByMaxFMeasure(1d);
    
    System.out.println("\nTopic Relevance Score");
    c.generateTopTopicRelevanceScore(10);
    
//    System.out.println("\nCollection Topic Map unSorted");
//    c.showCollectionTopicMap1();
    //c.getPrecission();
    //c.getRecall();
    c.generatePrecisionAndRecall();
    sb.append("CLUSTERING EVALUATION").append("\n");
    sb.append("  Purity:\t").append(c.getPurity()).append("\n");
    sb.append("  Precision:\t").append(c.getCollectionPrecision()).append("\n");
    sb.append("  Recall:\t").append(c.getCollectionRecall()).append("\n");
    sb.append("  F-Measure:\t").append(c.getFMeasure(1d)).append("\n");
    sb.append("\n");
    sb.append("TOP TOPIC (TRENDING TOPIC) EVALUATION").append("\n");
    sb.append("  nDCG:\t").append(c.getNormalizedDCG(10)).append("\n");

    evaluationResultTextArea.setText(sb.toString());
    
    //    clusterTopicMap = generateClusterTopicMap();
    // for each document url check the filter status
    
    // for CLUSTERING EVALUATION
    // calculate the value of precision, recall and f-measure of each document
    // using B-Cubed metric - Bagga & Baldwin [1998]
    
    // TODO : CALCULATE TOPIC DISTRIBUTION IN CURRENT COLLECTION
    
    // CALCULATE PRECISSION
    
    // for CLUSTER LABELING EVALUATION, decide what topic does a cluster belongs too.
    // here I stipulate that the topic of the cluster is decided by topic with most document in that cluster.
    // in an event of ties, each tied topic would be calculated and the result would be devided by the number of tied topic.
    // for example: if its ties between 3 topic. within a cluster of 7 document, with 4 topic. 3 of the topic are ties 
    // with 2 document. All 3 topic would be calculated, summed and then devided by 3.
    // this stipulation could give result one topic scored more than once.
    // so instead of deviding the sum of all result by the number of topic, i devide it by the number of cluster
    // there also a problem of singleton cluster, which is not labeled.
    // TODO : handle singleton cluster.
    
    
    
  }//GEN-LAST:event_evaluateButtonActionPerformed

  private void manualClusterFileBrowseButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_manualClusterFileBrowseButtonActionPerformed
    chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
      int r = chooser.showOpenDialog(this);
      if (r != javax.swing.JFileChooser.APPROVE_OPTION) {
        return;
      }
      manualClusterFileTextField.setText(chooser.getSelectedFile().getAbsolutePath());
  }//GEN-LAST:event_manualClusterFileBrowseButtonActionPerformed

  private void manualClusterLabelingFileBrowseButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_manualClusterLabelingFileBrowseButtonActionPerformed
    chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
    int r = chooser.showOpenDialog(this);
    if (r != javax.swing.JFileChooser.APPROVE_OPTION) {
      return;
    }
    manualClusterLabelingFileTextField.setText(chooser.getSelectedFile().getAbsolutePath());
  }//GEN-LAST:event_manualClusterLabelingFileBrowseButtonActionPerformed

  private void closeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closeButtonActionPerformed
    evaluationViewDialog.setVisible(false);
    dispose();
  }//GEN-LAST:event_closeButtonActionPerformed
  
  //<editor-fold defaultstate="collapsed" desc="URL FILTER LIST RETRIEVAL METHOD">
  /**
   * check if the input URL are included as new document
   * @param url
   * @return 
   */
  private boolean checkUrllist(String url) {
    if (this.includedURLList == null) {
      this.includedURLList = getURLList(appConf.URLFilterFile);
    }
    if (this.includedURLList.contains(url.trim())) {
      return true;
    }
    return false;
  }
  
  /**
   * Returns ArrayList of trimmed urlList String
   *
   * @param path the URLList file object.
   * @return HashSer of trimmed URL String
   */
  private static HashSet<String> getURLList(File file) {
    try {
      HashSet<String> sw = new HashSet<String>();
      BufferedReader br = new BufferedReader(new FileReader(file));
      String line = null;
      while ((line = br.readLine()) != null) {
        // discarding comments, empty line and consist only space characters
        if (!line.startsWith("#") && !line.isEmpty() && !line.matches("\\s+")) {
          sw.add(line.trim());
        }
      }
      br = null;
      return sw;
    } catch (FileNotFoundException ex) {
      ex.printStackTrace();
    } catch (IOException ex) {
      ex.printStackTrace();
    }
    return null;
  }
  //</editor-fold>
  
  //<editor-fold defaultstate="collapsed" desc="MANUAL CLUSTER BY TOPIC RETRIEVAL METHODS">
  /**
   *  Get the Topic ID for this input URL
   * @param url
   * @return Topic ID
   */
  private int getTopicID(String url) {
    if (this.URLTopicClusterList == null) {
      generateManualClusterList(new File(this.manualClusterFileTextField.getText()));
    }
    if (this.URLTopicClusterList.containsKey(url)) {
      return this.URLTopicClusterList.get(url.trim()).intValue();
    } else {
      System.out.println("No Topic found for: " + url);
      return 0;
    }
  }

  /**
   *  Generates map for URL-Topic/cluster member and Topic/Cluster member - URL
   * @param file -> mapped topic/cluster member per url
   */
  private void generateManualClusterList(File file) {
    try {
      HashMap<Integer, ArrayList<String>> topicURLMap = new HashMap<Integer, ArrayList<String>>();
      HashMap<String, Integer> urlTopicMap = new HashMap<String, Integer>();
      
      BufferedReader br = new BufferedReader(new FileReader(file));
      String line = null;
      while ((line = br.readLine()) != null) {
        // discarding comments, empty line and consist only space characters
        if (!line.startsWith("#") && !line.isEmpty() && !line.matches("\\s+")) {

          String[] part = line.split("\t", 3);
          String url = part[0].trim();
          int mainTopic = Integer.valueOf(part[1].trim()).intValue();
          
          if (topicURLMap.containsKey(mainTopic)) {
            topicURLMap.get(mainTopic).add(url);
          } else {
            ArrayList<String> urlList = new ArrayList<String>();
            urlList.add(url);
            topicURLMap.put(mainTopic, urlList);
          }
          
          urlTopicMap.put(url, mainTopic);
          
        }
      }
      br = null;
      
      URLTopicClusterList = urlTopicMap;
      topicURLClusterList = topicURLMap;
      
    } catch (FileNotFoundException ex) {
      ex.printStackTrace();
    } catch (IOException ex) {
      ex.printStackTrace();
    }
  }  
  //</editor-fold>
  
  //<editor-fold defaultstate="collapsed" desc="MANUAL CLUSTER LABELING RETRIEVAL METHODS">
  /**
   * Get Topic Object of input topic ID
   * @param topicID
   * @return Topic Object
   */
  private Topic getTopic(int topicID){
    if (this.topicList == null) {
      generateTopicList(new File(this.manualClusterLabelingFileTextField.getText()));
    }
    if (this.topicList.containsKey(topicID)) {
      return this.topicList.get(topicID);
    } else {
      System.out.println("No Topic found for topic ID: " + topicID);
      return null;
    }
  }
  
  /**
   *  Generate map of topic, consist of: Topic ID as Key and Topic Object as value.
   * @param file 
   */
  private void generateTopicList(File file){
    try {
      HashMap<Integer, Topic> topics = new HashMap<Integer, Topic>();;

      BufferedReader br = new BufferedReader(new FileReader(file));
      String line = null;
      while ((line = br.readLine()) != null) {
        // discarding comments, empty line and consist only space characters
        if (!line.startsWith("#") && !line.isEmpty() && !line.matches("\\s+")) {

          String[] part = line.split("\t");
          int topicID = Integer.valueOf(part[0].trim()).intValue(); // topic id
          String topicTitle = part[1].trim().toLowerCase(); // topic title
          
          Topic t = new Topic();
          t.topicID = topicID;
          t.topicTitle = topicTitle;
          
          for (int i = 2; i < part.length; i++) {
            String string = part[i];
            t.topicLabels.add(string.trim().toLowerCase());
          }
          topics.put(topicID, t);
        }
      }
      br = null;

      topicList = topics;

    } catch (FileNotFoundException ex) {
      ex.printStackTrace();
    } catch (IOException ex) {
      ex.printStackTrace();
    }
  }
  //</editor-fold>
  
  private class Topic {
    int topicID = 0;
    String topicTitle = "TOPIC_TITLE";
    ArrayList<String> topicLabels = new ArrayList<String>();
  }

  private class Coll {
    
    // <TopicID, NumOfDoc>
    private HashMap<Integer, Integer> collectionTopicMap = new HashMap<Integer, Integer>();
    
    // <ClusterIndex, NumOfDoc>
    private HashMap<Integer, Integer> collectionClusterMap = new HashMap<Integer, Integer>();
    
    // <ClusterIndex <TopicID, NumOfDoc>>
    private HashMap<Integer, HashMap<Integer, Integer>> clustTopicMap = new HashMap<Integer, HashMap<Integer, Integer>>();
    
    // <ClusterIndex, TopicID> // for cluster labeling and trend precission calculation
    private HashMap<Integer, Integer> clustSelectedTopic = new HashMap<Integer, Integer>();
    
    // <TopicID, RelevanceScore>
    LinkedHashMap<Integer, Integer>  topicRelevanceScore = new LinkedHashMap<Integer, Integer> ();
    
    private int numOfNonFilteredDoc = 0;
    private double precision = 0;
    private double recall = 0;
    private double purity = 0;

    private void generateClusterTopicMap(ArrayList<Vertex> vertices, boolean groupSinletonClusters) {

      // COUNT  CLUSTER TOPIC STATISTICS
      int clusterIndex = 1; // clusterIndex 0 are reserved for "other" node
      // for other node
      HashMap<Integer, Integer> topic_other_NumOfDoc = new HashMap<Integer, Integer>();
      int singleClusterNumOfDoc = 0;
      
      // for each document in cluster
      for (Vertex vertex : vertices) { // root vertex (cluster vertex)
        ArrayList<LuceneIndexDocument> clusterDocs = vertex.getClusterMembers();

        if (clusterDocs.size() > 1) { // only process vertex(cluster) that have merged atleast once
          HashMap<Integer, Integer> topic_NumOfDoc = new HashMap<Integer, Integer>();
          for (LuceneIndexDocument doc : clusterDocs) { // vertex cluster members
            String url = doc.getUrl();
            int topicID = getTopicID(url); // get TopicID for this URL

            if (topic_NumOfDoc.containsKey(topicID)) {
              topic_NumOfDoc.put(topicID, topic_NumOfDoc.get(topicID) + 1); // get number of topic in the cluster
            } else {
              topic_NumOfDoc.put(topicID, 1); // put a new TopicID on cluster
            }
            
            if (collectionTopicMap.containsKey(topicID)) {
              collectionTopicMap.put(topicID, collectionTopicMap.get(topicID) + 1);
            } else {
              collectionTopicMap.put(topicID, 1);
            }

            numOfNonFilteredDoc += 1;
          }
          collectionClusterMap.put(clusterIndex, clusterDocs.size());
          clustTopicMap.put(clusterIndex, topic_NumOfDoc);
          clusterIndex += 1;

        } else if (vertex.isIncludeInClustering()) { // other node (singleton cluster)
          LuceneIndexDocument doc = clusterDocs.get(0);
          String url = doc.getUrl();
          int topicID = getTopicID(url); // get TopicID for this URL

          
          if(groupSinletonClusters){
            if (topic_other_NumOfDoc.containsKey(topicID)) {
              topic_other_NumOfDoc.put(topicID, topic_other_NumOfDoc.get(topicID) + 1); // get number of topic in the cluster
            } else {
              topic_other_NumOfDoc.put(topicID, 1); // put a new TopicID on cluster
            }
            singleClusterNumOfDoc += 1;
          } else {
            HashMap<Integer, Integer> topic_NumOfDoc = new HashMap<Integer, Integer>();
            topic_NumOfDoc.put(topicID, 1); // put a new TopicID on cluster
            clustTopicMap.put(clusterIndex, topic_NumOfDoc);
            collectionClusterMap.put(clusterIndex, 1);
            clusterIndex += 1;
          }
          
          if (collectionTopicMap.containsKey(topicID)) {
            collectionTopicMap.put(topicID, collectionTopicMap.get(topicID) + 1);
          } else {
            collectionTopicMap.put(topicID, 1);
          }
          
          numOfNonFilteredDoc += 1;
        } else { /* "old" node --> ignore */ }
      }
      if(groupSinletonClusters){ 
        clustTopicMap.put(0, topic_other_NumOfDoc);
        collectionClusterMap.put(0, singleClusterNumOfDoc);
      } // put other nodes
 
    }
    
    private void showClusterTopicMap(){
      Iterator clusterMapIterator = clustTopicMap.keySet().iterator();
      while (clusterMapIterator.hasNext()) {
        Integer clusterID = (Integer) clusterMapIterator.next();
        System.out.println("\tClusterID : " + clusterID);
        HashMap<Integer, Integer> asdf = clustTopicMap.get(clusterID);
        Iterator topMapIterator = asdf.keySet().iterator();
        while (topMapIterator.hasNext()) { 
          Integer topicID = (Integer) topMapIterator.next();
          Integer numOfDoc = (Integer) asdf.get(topicID);
          System.out.println("\t  Topic: " + topicID + " Num of Doc: " + numOfDoc);
        }
      }
    }
    
    private void showCollectionTopicMap(){
      
      LinkedHashMap<Integer, Integer> collectionTopicMapSorted = sortHashMapByValueDIntInt(collectionTopicMap);
      
      Iterator collectionTopicMapIterator = collectionTopicMapSorted.keySet().iterator();
      while (collectionTopicMapIterator.hasNext()) {
        Integer topicID = (Integer) collectionTopicMapIterator.next();
        Integer numOfTopic = (Integer) collectionTopicMapSorted.get(topicID);
        System.out.println("\tTopic: " + topicID + " Num of Doc: " + numOfTopic);
      }
    }
    
    private void showNumOfNonFilteredDoc(){
      System.out.println("  Number of Non-Filtered Doc: "+numOfNonFilteredDoc);
    }
    
    private double getCollectionPrecision(){
      if(precision == 0){
        Iterator clusterMapIterator = clustTopicMap.keySet().iterator();
        while (clusterMapIterator.hasNext()) { // iterate through all the cluster
          Integer clusterID = (Integer) clusterMapIterator.next();
          HashMap<Integer, Integer> TopicNumOfDocInCluster = clustTopicMap.get(clusterID);
          int numOfDocInCluster = 0;
          int clusterTopicVal = 0;
          Iterator topMapIterator = TopicNumOfDocInCluster.keySet().iterator();
          while (topMapIterator.hasNext()) { // iterate through all topic in this cluster
            Integer topicID = (Integer) topMapIterator.next();
            Integer numOfDoc = (Integer) TopicNumOfDocInCluster.get(topicID);
            numOfDocInCluster += numOfDoc;
            clusterTopicVal += (double) numOfDoc * (double) numOfDoc;
          }
          precision += (double) clusterTopicVal / (double) numOfDocInCluster;
        }
        precision = precision / (double) numOfNonFilteredDoc;
      }
      return precision;
    }
    
    private double getCollectionRecall(){
      if(recall == 0){
        Iterator clusterMapIterator = clustTopicMap.keySet().iterator();
        while (clusterMapIterator.hasNext()) { // iterate through all the cluster
          Integer clusterID = (Integer) clusterMapIterator.next();
          HashMap<Integer, Integer> TopicNumOfDocInCluster = clustTopicMap.get(clusterID);
          double clusterTopicVal = 0;
          Iterator topMapIterator = TopicNumOfDocInCluster.keySet().iterator();
          while (topMapIterator.hasNext()) { // iterate through all topic in this cluster
            Integer topicID = (Integer) topMapIterator.next();
            Integer numOfDoc = (Integer) TopicNumOfDocInCluster.get(topicID);
            clusterTopicVal += (double) (numOfDoc * numOfDoc) / (double) collectionTopicMap.get(topicID);
          }
          recall += clusterTopicVal;
        }
        recall = recall / (double) numOfNonFilteredDoc;
      }
      return recall;
    }
    
    private void generatePrecisionAndRecall(){
      Iterator clusterMapIterator = clustTopicMap.keySet().iterator();
      while (clusterMapIterator.hasNext()) { // iterate through all the cluster
        Integer clusterID = (Integer) clusterMapIterator.next();
        HashMap<Integer, Integer> TopicNumOfDocInCluster = clustTopicMap.get(clusterID);
        int numOfDocInCluster = 0;
        int clusterTopicVal = 0;
        Iterator topMapIterator = TopicNumOfDocInCluster.keySet().iterator();
        while (topMapIterator.hasNext()) { // iterate through all topic in this cluster
          Integer topicID = (Integer) topMapIterator.next();
          Integer numOfDoc = (Integer) TopicNumOfDocInCluster.get(topicID);
          numOfDocInCluster += (double) numOfDoc;
          clusterTopicVal += (double) numOfDoc * (double) numOfDoc;
          recall += (double)(numOfDoc * numOfDoc)/(double)collectionTopicMap.get(topicID);
        }
        precision += (double) clusterTopicVal / (double) numOfDocInCluster;
      }
      precision = precision / (double) numOfNonFilteredDoc;
      recall = recall/(double)numOfNonFilteredDoc;
    }
    
    private void generatePurity(){
      Iterator clusterMapIterator = clustTopicMap.keySet().iterator();
      while (clusterMapIterator.hasNext()) { // iterate through all the cluster
        Integer clusterID = (Integer) clusterMapIterator.next();
        HashMap<Integer, Integer> TopicNumOfDocInCluster = clustTopicMap.get(clusterID);
        Iterator topMapIterator = TopicNumOfDocInCluster.keySet().iterator();
        int maxNumOfDoc = 0;
        while (topMapIterator.hasNext()) { // iterate through all topic in this cluster
          Integer topicID = (Integer) topMapIterator.next();
          Integer numOfDoc = (Integer) TopicNumOfDocInCluster.get(topicID);
          if(numOfDoc >= maxNumOfDoc) maxNumOfDoc = numOfDoc;
        }
        purity += (double) maxNumOfDoc;
      }
      purity = purity / (double) numOfNonFilteredDoc;
    }
    
    private double getPurity(){
      if(purity == 0) generatePurity();
      return purity;
    }
    
    /**
        * return the F-Measure Value.
        * if the precision and recall are haven't been generated or one of it's value are 0, 
        * the return value are 0
        * @param β between 0 and positive unlimited
        * @return 
        */
    private double getFMeasure(double β) {
      if (precision != 0 && recall != 0) {
        double f = (1d + Math.pow(β, 2d))
                * ((precision * recall) / ((β * precision) + recall));
        return f;
      } else {
        return 0;
      }

    }
    
    /**
        *  Using maximum topic Precision on each cluster
        *  one topic could only selected once
        *  the process started from the cluster with the most document.
        */
    private void generateClusterTopicByMaxPrecision(){
      HashMap<Integer, Integer> clusterTopic = new HashMap<Integer, Integer>();
      Iterator clusterMapIterator = clustTopicMap.keySet().iterator();
      while (clusterMapIterator.hasNext()) { // iterate through all the cluster
        Integer clusterID = (Integer) clusterMapIterator.next();
        HashMap <Integer, Integer> TopicNumOfDocInClusterUnSorted = clustTopicMap.get(clusterID);
        
        LinkedHashMap<Integer, Integer> TopicNumOfDocInClusterSorted = 
                sortHashMapByValueDIntInt(TopicNumOfDocInClusterUnSorted);
        
        for (Integer topicID : TopicNumOfDocInClusterSorted.keySet()) {
          if(!clusterTopic.containsValue(topicID)){
            clusterTopic.put(clusterID, topicID);
            System.out.println("\tclusterID["+clusterID +"] topicID["+topicID + "] numOfDoc[" + 
                    TopicNumOfDocInClusterSorted.get(topicID)+"] of "+collectionClusterMap.get(clusterID));
            break;
          }
        }
        // if there is no topic selected for this cluster, then assign that cluster as topic 0.
        // topic 0 are permitted to be assigned to more than 1 topic
        if(!clusterTopic.containsKey(clusterID)){
          clusterTopic.put(clusterID, 0);
          System.out.println("\tclusterID[" + clusterID + "] topicID[0] numOfDoc["
                  + TopicNumOfDocInClusterSorted.get(0) + "] of " + collectionClusterMap.get(clusterID));
        }
        
      }
      clustSelectedTopic = clusterTopic;
    }
    
   /**
      *  Using maximum topic F-Measure on each cluster
      *  one topic could only selected once
      *  the process started from the cluster with the most document.
      * @param β the Beta Variable for F-Measure (Beta)
      */
    private void generateClusterTopicByMaxFMeasure(double β){
      HashMap<Integer, Integer> clusterTopic = new HashMap<Integer, Integer>();
      Iterator clusterMapIterator = clustTopicMap.keySet().iterator();
      while (clusterMapIterator.hasNext()) { // iterate through all the cluster
        Integer clusterID = (Integer) clusterMapIterator.next();
        
        HashMap <Integer, Integer> TopicNumOfDocInClusterUnSorted = clustTopicMap.get(clusterID);
        HashMap <Integer, Double> TopicFMeasureInClusterUnSorted = new HashMap<Integer, Double>();
        
        Iterator topMapIterator = TopicNumOfDocInClusterUnSorted.keySet().iterator();
        while (topMapIterator.hasNext()) { // iterate through all topic in this cluster
          Integer topicID = (Integer) topMapIterator.next();
          Integer topicNumOfDoc = (Integer) TopicNumOfDocInClusterUnSorted.get(topicID);
          
          double clusterTopicPrecision;
          double clusterTopicRecall;
          double clusterTopicFMeasure;
          
          //precision = topicNumOfDoc/clusterNumOfDoc
          clusterTopicPrecision = (double) topicNumOfDoc / (double) collectionClusterMap.get(clusterID);
          //recall = topicNumOfDoc/topicNumOfDoc
          clusterTopicRecall = (double) topicNumOfDoc / (double) collectionTopicMap.get(topicID);
          // FMeasure = (1 + (β pow 2)) * ((precision * recall) / ((β * precision) + recall)
          clusterTopicFMeasure = (1d + Math.pow(β, 2d))
                  * ((clusterTopicPrecision * clusterTopicRecall) / ((β * clusterTopicPrecision) + clusterTopicRecall));
          
          TopicFMeasureInClusterUnSorted.put(topicID, clusterTopicFMeasure);
        }
        
        LinkedHashMap<Integer, Double> TopicFMeasureInClusterSorted = sortHashMapByValueDIntDouble(TopicFMeasureInClusterUnSorted);
        
        for (Integer topicID : TopicFMeasureInClusterSorted.keySet()) {
          if(!clusterTopic.containsValue(topicID)){
            clusterTopic.put(clusterID, topicID);
            System.out.println("\tclusterID["+clusterID +"] topicID["+topicID + "] FMeasure[" + TopicFMeasureInClusterSorted.get(topicID)+"]");
            break;
          }
        }
      }
      clustSelectedTopic = clusterTopic;
    }

    private void setNoiseLevel(){
      /**
       * consider a cluster P that has the set of subcluster, denoted as children(P).
       * For each document in any subcluster of P, the document reassigned to another subcluster of P,
       * with a probability N (Noise %); with the probability 1-N, the document remains in the correct subcluster.
       * The probability that a document reassigned to a subcluster C of P is proportional to the size of the cluster C.
       * So the probability that a document d in a cluster P is assigned to a subcluster C of P, denoted by Pr(assigned(d,C)), is:
       * 
       *  Pr(assigned(d,C)) = 1-N, if d∈ C
       *  Pr(assigned(d,C)) = N * (|C|/(∑ R ∈ children(P) and d ∉ R)|R|), if d ∉ C
       * 
       * where |C| denotes the number of documents that originally belonged to the cluster C.
       */
    }
    
    private void generateTopTopicRelevanceScore(int n){
      // for each top n topic, generate relevance score
      // relevance score value are decreasing by 1 from the top topic.
      // top topic are the topic that have the most document, except for topic "others" topicID = 0
      // topic with the same number of documents given the same relevance score
      // since the maximum value of relevance score are not known,
      // the maximum relevance score are decided by assigning 1 to n th topic,
      // the increase it by one for each topic that have more document.
      // since there are a big chance that the n th topic have the same number of documents for n+1 top topic
      // for example:
      // n = 10.
      // TopTopic 10 = have 3 documents
      // TopTopic 11 = have 3 documents
      // TopTopic 12 = have 3 documents
      // TopTopic 13 = have 2 documents
      // top topic 11 and 12 are included but top topic 13 not because it's doesnt have the same number of documents
      // the result of this configuration is the top N topic could result N+m Topic included.
      // the reason for this configuration is because there are no way to ensure which topic apear first on Top N.
      // <topicID, relevance Score>
      HashMap<Integer, Integer> topicRelevanceScoreMap = new HashMap<Integer, Integer>();
      
      LinkedHashMap<Integer, Integer> collectionTopicMapSorted = sortHashMapByValueDIntInt(collectionTopicMap);
      
      int counter = 0;
      int RelevanceScore = 0;
      int lastNumOfTopic = 0;
      
      // generate top relevance Score
      Iterator collectionTopicMapIterator = collectionTopicMapSorted.keySet().iterator();
      while (counter < n && collectionTopicMapIterator.hasNext()) {
        
        Integer topicID = (Integer) collectionTopicMapIterator.next();
        Integer numOfTopic = (Integer) collectionTopicMapSorted.get(topicID);
        
        System.out.println("topicID: "+topicID);
        if(topicID == 0) continue;
        
        if(numOfTopic != lastNumOfTopic){
          RelevanceScore += 1;
          lastNumOfTopic = numOfTopic;
        }
        counter += 1;
      }
      
      // assign relevance score
      lastNumOfTopic = 0;
      collectionTopicMapIterator = collectionTopicMapSorted.keySet().iterator();
      while (RelevanceScore >= 0 && collectionTopicMapIterator.hasNext()) {
        Integer topicID = (Integer) collectionTopicMapIterator.next();
        Integer numOfTopic = (Integer) collectionTopicMapSorted.get(topicID);
        
        if(topicID == 0) continue;

        if(numOfTopic != lastNumOfTopic){
          RelevanceScore -= 1;
          lastNumOfTopic = numOfTopic;
        }     
        
        if(RelevanceScore < 0) break;
          
        topicRelevanceScoreMap.put(topicID, RelevanceScore+1);
        
      }
      
      //print to screen
      LinkedHashMap<Integer, Integer> topicRelevanceScoreMapSorted = sortHashMapByValueDIntInt(topicRelevanceScoreMap);
      
      collectionTopicMapIterator = topicRelevanceScoreMapSorted.keySet().iterator();
      while (collectionTopicMapIterator.hasNext()) {
        Integer topicID = (Integer) collectionTopicMapIterator.next();
        Integer relevanceScore = (Integer) topicRelevanceScoreMapSorted.get(topicID);
        System.out.println("\tTopic: " + topicID + " relevanceScore: " + relevanceScore);
      }
      topicRelevanceScore = topicRelevanceScoreMapSorted;
    }
    
    private double getNormalizedDCG(int n){
      double DCG = 0;
      double idealDCG = 0;
      double normalizedDCG = 0;
      
      // Generate Discounted Cumulative Gain Value
      System.out.println("\n\tCluster Relevance Score Sequence");
      int counter = 1;
      int minus = 0; // hack variable
      while (counter <= n){
        int clustTopicID = clustSelectedTopic.get(counter+minus);
        if(clustTopicID == 0){ minus += 1; continue; }// ignore "others" topic
        int relScore = 0;
        if(topicRelevanceScore.containsKey(clustTopicID))
          relScore = topicRelevanceScore.get(clustTopicID);
        
        System.out.println("\tcounter: "+counter+" clustTopicID: "+clustTopicID+" relScore: "+relScore);
        
        if(counter == 1)
          DCG = relScore;
        else
          DCG += relScore/(Math.log(counter)/Math.log(2d));
        
        counter += 1;
      }
      System.out.println("\tDCG: "+ DCG);
      
      // Generate Ideal Discounted Cumulative Gain Value
      System.out.println("\n\tIdeal Relevance Score Sequence");
      counter = 1;
      Iterator collectionTopicMapIterator = topicRelevanceScore.keySet().iterator();
      while (counter <= n && collectionTopicMapIterator.hasNext()) {
        Integer topicID = (Integer) collectionTopicMapIterator.next();
        Integer relevanceScore = (Integer) topicRelevanceScore.get(topicID);
        
        System.out.println("\tcounter: "+counter+" topicID: "+topicID+" relevanceScore: "+relevanceScore);
        
        if(counter == 1)
          idealDCG = relevanceScore;
        else
          idealDCG += relevanceScore/(Math.log(counter)/Math.log(2d));
        
        counter += 1;
      }
      System.out.println("\tidealDCG: "+idealDCG);
      
      normalizedDCG = DCG/idealDCG;
      
      return normalizedDCG;
    }
    
    private LinkedHashMap<Integer, Integer> sortHashMapByValueDIntInt(HashMap<Integer, Integer> passedMap) {
      HashMap<Integer, Integer> copyHashMap = new HashMap<Integer, Integer>();
      for (Integer wsState : passedMap.keySet()) {
        copyHashMap.put(wsState, passedMap.get(wsState));
      }
      
      List mapKeys = new ArrayList(copyHashMap.keySet());
      List mapValues = new ArrayList(copyHashMap.values());
      Collections.sort(mapValues, new byBiggestInteger());
      Collections.sort(mapKeys, new byBiggestInteger());

      LinkedHashMap<Integer, Integer> sortedMap = new LinkedHashMap<Integer, Integer>();

      Iterator valueIt = mapValues.iterator();
      while (valueIt.hasNext()) {
        Object val = valueIt.next();
        Iterator keyIt = mapKeys.iterator();

        while (keyIt.hasNext()) {
          Object key = keyIt.next();
          String comp1 = copyHashMap.get(key).toString();
          String comp2 = val.toString();

          if (comp1.equals(comp2)) {
            copyHashMap.remove(key);
            mapKeys.remove(key);
            sortedMap.put((Integer) key, (Integer) val);
            break;
          }
        }
      }
      return sortedMap;
    }
    
    private LinkedHashMap<Integer, Double> sortHashMapByValueDIntDouble(HashMap<Integer, Double> passedMap) {
      HashMap<Integer, Double> copyHashMap = new HashMap<Integer, Double>();
      for (Integer wsState : passedMap.keySet()) {
        copyHashMap.put(wsState, passedMap.get(wsState));
      }
      
      List mapKeys = new ArrayList(copyHashMap.keySet());
      List mapValues = new ArrayList(copyHashMap.values());
      Collections.sort(mapValues);
      Collections.sort(mapKeys);

      LinkedHashMap<Integer, Double> sortedMap = new LinkedHashMap<Integer, Double>();

      Iterator valueIt = mapValues.iterator();
      while (valueIt.hasNext()) {
        Object val = valueIt.next();
        Iterator keyIt = mapKeys.iterator();

        while (keyIt.hasNext()) {
          Object key = keyIt.next();
          String comp1 = copyHashMap.get(key).toString();
          String comp2 = val.toString();

          if (comp1.equals(comp2)) {
            copyHashMap.remove(key);
            mapKeys.remove(key);
            sortedMap.put((Integer) key, (Double) val);
            break;
          }
        }
      }
      return sortedMap;
    }
  
    
  }
  
  public static class byBiggestInteger implements java.util.Comparator {

    public int compare(Object t, Object t1) {
      int max = (Integer) t1 - (Integer) t;
      return max;
    }
  }
  
  public static class byBiggestDouble implements java.util.Comparator {

    public int compare(Object t, Object t1) {
      int max = (Integer) t1 - (Integer) t;
      return max;
    }
  }
  
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton closeButton;
  private javax.swing.JLabel clusterEvaluationCalculateLabel;
  private javax.swing.JLabel clusterLabelingEvaluationRefLabel;
  private javax.swing.JLabel clusteringEvaluationFMeasureBetaLabel;
  private javax.swing.JLabel clusteringEvaluationFMeasureBetaLabel1;
  private javax.swing.JSpinner clusteringEvaluationFMeasureBetaSpinner;
  private javax.swing.JSpinner clusteringEvaluationFMeasureBetaSpinner1;
  private javax.swing.JCheckBox clusteringEvaluationFMeasureCheckBox;
  private javax.swing.JLabel clusteringEvaluationLabel;
  private javax.swing.JCheckBox clusteringEvaluationPrecisionRecallCheckBox;
  private javax.swing.JCheckBox clusteringEvaluationPurityCheckBox;
  private javax.swing.JLabel clusteringEvaluationRefLabel;
  private javax.swing.JButton evaluateButton;
  private javax.swing.JTextArea evaluationResultTextArea;
  private javax.swing.JCheckBox jCheckBox1;
  private javax.swing.JCheckBox jCheckBox10;
  private javax.swing.JCheckBox jCheckBox2;
  private javax.swing.JCheckBox jCheckBox3;
  private javax.swing.JCheckBox jCheckBox4;
  private javax.swing.JCheckBox jCheckBox5;
  private javax.swing.JCheckBox jCheckBox6;
  private javax.swing.JCheckBox jCheckBox7;
  private javax.swing.JCheckBox jCheckBox8;
  private javax.swing.JCheckBox jCheckBox9;
  private javax.swing.JComboBox jComboBox1;
  private javax.swing.JLabel jLabel1;
  private javax.swing.JLabel jLabel2;
  private javax.swing.JLabel jLabel4;
  private javax.swing.JLabel jLabel5;
  private javax.swing.JLabel jLabel6;
  private javax.swing.JLabel jLabel8;
  private javax.swing.JScrollPane jScrollPane1;
  private javax.swing.JSpinner jSpinner1;
  private javax.swing.JSpinner jSpinner2;
  private javax.swing.JButton manualClusterFileBrowseButton;
  private javax.swing.JLabel manualClusterFileLabel;
  private javax.swing.JTextField manualClusterFileTextField;
  private javax.swing.JButton manualClusterLabelingFileBrowseButton;
  private javax.swing.JLabel manualClusterLabelingFileLabel;
  private javax.swing.JTextField manualClusterLabelingFileTextField;
  // End of variables declaration//GEN-END:variables
  private static EvaluationViewDialog evaluationViewDialog;
  private JFileChooser chooser = new JFileChooser();
  

}
